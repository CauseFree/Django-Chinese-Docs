===========
初探 Django
===========

因为 Django 是在一个快节奏的新闻编辑部中开发出来的，它被设计用来让普通的网站开发工作简单快
捷。以下是一个教你使用 Django 创建一个数据库驱动的网站应用的大纲。

这个文档的目标是让你有足够的技巧和能力了解 Django 是如何工作的，但是它并不是表示它是一个新
手指南或者参考目录 -- 其实这些我们都有！当你准备好新建一个项目，你可以 :doc:`从新手指南开始
</intro/tutorial01>` 或者 :doc:`深入阅读详细的文档 </topics/index>`.

设计你的 model
==============

尽管你在 Django 中可以不使用数据库，但是它提供了一个完善的可以用 Python 代码描述你的数据库
结构的对象关联映射(ORM)。

:doc:`model 语法 </topics/db/models>` 提供了丰富的表现你的 models 的方法 -- 目前为止，它解
决了不少关于数据库模式的问题。the file这里是一个简单的例子，一般保存在一个名为
``mysite/news/models.py`` 的文件中::

    class Reporter(models.Model):
        full_name = models.CharField(max_length=70)

        def __unicode__(self):
            return self.full_name

    class Article(models.Model):
        pub_date = models.DateTimeField()
        headline = models.CharField(max_length=200)
        content = models.TextField()
        reporter = models.ForeignKey(Reporter)

        def __unicode__(self):
            return self.headline

安装
====

下一步，运行 Django 命令行工具来自动创建数据库表:

.. code-block:: bash

    manage.py syncdb

:djadmin:`syncdb` 命令会查找所有可用的 models 然后在数据库中创建还不存在的数据库表。

享用便捷的 API
==============

通过它，你可以使用一个方便功能丰富的 :doc:`Python API </topics/db/queries>` 来访问你的数据。
API 是动态生成的，不需要生成代码::

    # 导入我们在 "news" app 中创建的 models
    >>> from news.models import Reporter, Article

    # 在系统中目前还没有 reporters
    >>> Reporter.objects.all()
    []

    # 创建一个新的 Reporter 
    >>> r = Reporter(full_name='John Smith')

    # 将对象保存到数据库。你需要显示的调用 save() 方法。
    >>> r.save()

    # 现在它有一个 ID 了。
    >>> r.id
    1

    # 现在新的 reporter 已经在数据库里面了。
    >>> Reporter.objects.all()
    [<Reporter: John Smith>]

    # 字段被表示为一个 Python 对象的属性。
    >>> r.full_name
    'John Smith'

    # Django 提供了丰富的数据库查询 API。
    >>> Reporter.objects.get(id=1)
    <Reporter: John Smith>
    >>> Reporter.objects.get(full_name__startswith='John')
    <Reporter: John Smith>
    >>> Reporter.objects.get(full_name__contains='mith')
    <Reporter: John Smith>
    >>> Reporter.objects.get(id=2)
    Traceback (most recent call last):
        ...
    DoesNotExist: Reporter matching query does not exist.

    # 创建一个 article
    >>> from datetime import datetime
    >>> a = Article(pub_date=datetime.now(), headline='Django is cool',
    ...     content='Yeah.', reporter=r)
    >>> a.save()

    # 现在 article 已经在数据库中了。
    >>> Article.objects.all()
    [<Article: Django is cool>]

    # Article 对象有 API 可以访问到关联到 Reporter 对象。
    >>> r = a.reporter
    >>> r.full_name
    'John Smith'

    # 反之亦然：Reporter 对象也有访问 Article 对象的API。
    >>> r.article_set.all()
    [<Article: Django is cool>]

    # API 会在后台有效的联合表，以便满足你的关联查询的要求。
    # 以下这个例子会找出 名字以 "John" 开头的 reporter 的所有的 articles。
    >>> Article.objects.filter(reporter__full_name__startswith="John")
    [<Article: Django is cool>]

    # 通过更改一个对象的属性，然后调用 save() 方法来改变一个对象的值。
    >>> r.full_name = 'Billy Goat'
    >>> r.save()

    # 使用 delete() 方法删除一个对象。
    >>> r.delete()

一个动态的 admin 管理界面: 它不只是个空架子 -- 它功能强大
=========================================================

一旦你的 models 被定义好，Django 能自动创建一个专业的，可以用于生产环境的 :doc:`管理界面接
口 </ref/contrib/admin/index>` -- 一个让满足权限的用户增加删除修改数据对象的网站。它使用起
来也非常简单只需要在你的 admin site 中注册你的 model 即可::

    # In models.py...

    from django.db import models

    class Article(models.Model):
        pub_date = models.DateTimeField()
        headline = models.CharField(max_length=200)
        content = models.TextField()
        reporter = models.ForeignKey(Reporter)


    # In admin.py in the same directory...

    import models
    from django.contrib import admin

    admin.site.register(models.Article)

这种设计的哲学是你的网站一般会由一个员工或者客户编辑，或者仅仅是你自己 -- 而你应该不会想要
仅仅为了管理内容而去创建后台界面。

在一个创建 Django 应用的典型工作流中，首先需要创建 models 并尽快让 admin sites 工作起来，这
样你的员工(或者客户)能够开始录入数据。然后，开发数据被展示给公众的方法。

设计你的 URLs
=============

A clean, elegant URL scheme is an important detail in a high-quality Web
application. Django encourages beautiful URL design and doesn't put any cruft
in URLs, like ``.php`` or ``.asp``.

To design URLs for an app, you create a Python module called a :doc:`URLconf
</topics/http/urls>`. A table of contents for your app, it contains a simple mapping
between URL patterns and Python callback functions. URLconfs also serve to
decouple URLs from Python code.

Here's what a URLconf might look like for the ``Reporter``/``Article``
example above::

    from django.conf.urls import patterns, url, include

    urlpatterns = patterns('',
        (r'^articles/(\d{4})/$', 'news.views.year_archive'),
        (r'^articles/(\d{4})/(\d{2})/$', 'news.views.month_archive'),
        (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'news.views.article_detail'),
    )

The code above maps URLs, as simple regular expressions, to the location of
Python callback functions ("views"). The regular expressions use parenthesis to
"capture" values from the URLs. When a user requests a page, Django runs
through each pattern, in order, and stops at the first one that matches the
requested URL. (If none of them matches, Django calls a special-case 404 view.)
This is blazingly fast, because the regular expressions are compiled at load
time.

Once one of the regexes matches, Django imports and calls the given view, which
is a simple Python function. Each view gets passed a request object --
which contains request metadata -- and the values captured in the regex.

For example, if a user requested the URL "/articles/2005/05/39323/", Django
would call the function ``news.views.article_detail(request,
'2005', '05', '39323')``.

Write your views
================

Each view is responsible for doing one of two things: Returning an
:class:`~django.http.HttpResponse` object containing the content for the
requested page, or raising an exception such as :class:`~django.http.Http404`.
The rest is up to you.

Generally, a view retrieves data according to the parameters, loads a template
and renders the template with the retrieved data. Here's an example view for
``year_archive`` from above::

    def year_archive(request, year):
        a_list = Article.objects.filter(pub_date__year=year)
        return render_to_response('news/year_archive.html', {'year': year, 'article_list': a_list})

This example uses Django's :doc:`template system </topics/templates>`, which has
several powerful features but strives to stay simple enough for non-programmers
to use.

Design your templates
=====================

The code above loads the ``news/year_archive.html`` template.

Django has a template search path, which allows you to minimize redundancy among
templates. In your Django settings, you specify a list of directories to check
for templates. If a template doesn't exist in the first directory, it checks the
second, and so on.

Let's say the ``news/year_archive.html`` template was found. Here's what that
might look like:

.. code-block:: html+django

    {% extends "base.html" %}

    {% block title %}Articles for {{ year }}{% endblock %}

    {% block content %}
    <h1>Articles for {{ year }}</h1>

    {% for article in article_list %}
        <p>{{ article.headline }}</p>
        <p>By {{ article.reporter.full_name }}</p>
        <p>Published {{ article.pub_date|date:"F j, Y" }}</p>
    {% endfor %}
    {% endblock %}

Variables are surrounded by double-curly braces. ``{{ article.headline }}``
means "Output the value of the article's headline attribute." But dots aren't
used only for attribute lookup: They also can do dictionary-key lookup, index
lookup and function calls.

Note ``{{ article.pub_date|date:"F j, Y" }}`` uses a Unix-style "pipe" (the "|"
character). This is called a template filter, and it's a way to filter the value
of a variable. In this case, the date filter formats a Python datetime object in
the given format (as found in PHP's date function; yes, there is one good idea
in PHP).

You can chain together as many filters as you'd like. You can write custom
filters. You can write custom template tags, which run custom Python code behind
the scenes.

Finally, Django uses the concept of "template inheritance": That's what the
``{% extends "base.html" %}`` does. It means "First load the template called
'base', which has defined a bunch of blocks, and fill the blocks with the
following blocks." In short, that lets you dramatically cut down on redundancy
in templates: each template has to define only what's unique to that template.

Here's what the "base.html" template might look like:

.. code-block:: html+django

    <html>
    <head>
        <title>{% block title %}{% endblock %}</title>
    </head>
    <body>
        <img src="sitelogo.gif" alt="Logo" />
        {% block content %}{% endblock %}
    </body>
    </html>

Simplistically, it defines the look-and-feel of the site (with the site's logo),
and provides "holes" for child templates to fill. This makes a site redesign as
easy as changing a single file -- the base template.

It also lets you create multiple versions of a site, with different base
templates, while reusing child templates. Django's creators have used this
technique to create strikingly different cell-phone editions of sites -- simply
by creating a new base template.

Note that you don't have to use Django's template system if you prefer another
system. While Django's template system is particularly well-integrated with
Django's model layer, nothing forces you to use it. For that matter, you don't
have to use Django's database API, either. You can use another database
abstraction layer, you can read XML files, you can read files off disk, or
anything you want. Each piece of Django -- models, views, templates -- is
decoupled from the next.

This is just the surface
========================

This has been only a quick overview of Django's functionality. Some more useful
features:

* A :doc:`caching framework </topics/cache>` that integrates with memcached
  or other backends.

* A :doc:`syndication framework </ref/contrib/syndication>` that makes
  creating RSS and Atom feeds as easy as writing a small Python class.

* More sexy automatically-generated admin features -- this overview barely
  scratched the surface.

The next obvious steps are for you to `download Django`_, read :doc:`the
tutorial </intro/tutorial01>` and join `the community`_. Thanks for your
interest!

.. _download Django: https://www.djangoproject.com/download/
.. _the community: https://www.djangoproject.com/community/
