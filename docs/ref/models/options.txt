===================
Model ``Meta`` 选项
===================

本文介绍你能在model中使用的 ``class Meta`` 内嵌类的所有 :ref:`元数据选项 (meta options)
<meta-options>`


``Meta`` 可用选项 (Available ``Meta`` options)
==============================================

.. currentmodule:: django.db.models

``abstract``
------------

.. attribute:: Options.abstract

    如果 ``abstract = True``, 这个 model 就是一个 :ref:`抽象基类 <abstract-base-classes>`.

``app_label``
-------------

.. attribute:: Options.app_label

    如果一个 model 定义在默认的 :file:`models.py` 之外 (例如, 如果你的 app 的 models 在
    ``myapp.models`` 子模块下), 你必须定义 app_label 让 Django 知道它属于哪一个 app ::

        app_label = 'myapp'

``db_table``
------------

.. attribute:: Options.db_table

    定义该 model 在数据中的表名称::

        db_table = 'music_album'

.. _table-names:


数据库中的表名称
~~~~~~~~~~~~~~~~

为了节省时间, Django 会自动的使用你的 model class 的名称和包含这个 model 的 app 名称来构建
数据库的表名称. 一个 model 的数据库表名称是通过将 "app label" -- 你在 :djadmin:`manage.py
startapp <startapp>` 中使用的名称 -- 和 model 的类名称， 加上一个下划线在他们之间来构成.

例如, 如果你有一个 app ``bookstore`` (使用 ``manage.py startapp bookstore`` 创建), 以及一个
model 定义为 ``class Book`` 这样将创建一个名为 ``bookstore_book`` 的数据库表.

如果想自定义数据库的表名称, 需要在 ``class Meta`` 使用 ``db_table`` 参数来自定义.

如果你的数据库表名称是一个SQL保留字, 或者它包含不允许出现在 Python 变量中的字符 (比如连字符)
这是没问题的. 这是因为 Django 会自动给列名和表名添加引号.

.. admonition:: 在 MySQL 中使用小写字母作为数据库表名称

    强烈建议你在通过 ``db_table`` 重载数据库表名称时, 使用小写字母, 特别是当你在使用 MySQL
    作为后台数据库时. 查看 :ref:`MySQL notes <mysql-notes>` 了解更多细节.

``db_tablespace``
-----------------

.. attribute:: Options.db_tablespace

    定义这个 model 所使用的 :doc:`数据库 表空间 </topics/db/tablespaces>`. 如果在项目的
    setting 中定义了 :setting:`DEFAULT_TABLESPACE` 那么它会使用这个值. 如果后台数据库不支持
    表空间, 这个选项会被忽略.

``get_latest_by``
-----------------

.. attribute:: Options.get_latest_by

    在 model 中指定一个 :class:`DateField` 或者 :class:`DateTimeField` . 这个设置让你在使用
    model 的 :class:`Manager` 上的 :class:`~QuerySet.latest` 方法时, 默认使用指定字段来排序.

    例如::

        get_latest_by = "order_date"

    详见 :meth:`~django.db.models.query.QuerySet.latest` .

``managed``
-----------

.. attribute:: Options.managed

    Defaults to ``True``, meaning Django will create the appropriate database
    tables in :djadmin:`syncdb` and remove them as part of a :djadmin:`reset`
    management command. That is, Django *manages* the database tables'
    lifecycles.

    If ``False``, no database table creation or deletion operations will be
    performed for this model. This is useful if the model represents an existing
    table or a database view that has been created by some other means. This is
    the *only* difference when ``managed=False``. All other aspects of
    model handling are exactly the same as normal. This includes

    1. Adding an automatic primary key field to the model if you don't
       declare it.  To avoid confusion for later code readers, it's
       recommended to specify all the columns from the database table you
       are modeling when using unmanaged models.

    2. If a model with ``managed=False`` contains a
       :class:`~django.db.models.ManyToManyField` that points to another
       unmanaged model, then the intermediate table for the many-to-many
       join will also not be created. However, the intermediary table
       between one managed and one unmanaged model *will* be created.

       If you need to change this default behavior, create the intermediary
       table as an explicit model (with ``managed`` set as needed) and use
       the :attr:`ManyToManyField.through` attribute to make the relation
       use your custom model.

    For tests involving models with ``managed=False``, it's up to you to ensure
    the correct tables are created as part of the test setup.

    If you're interested in changing the Python-level behavior of a model class,
    you *could* use ``managed=False`` and create a copy of an existing model.
    However, there's a better approach for that situation: :ref:`proxy-models`.

``order_with_respect_to``
-------------------------

.. attribute:: Options.order_with_respect_to

    Marks this object as "orderable" with respect to the given field. This is almost
    always used with related objects to allow them to be ordered with respect to a
    parent object. For example, if an ``Answer`` relates to a ``Question`` object,
    and a question has more than one answer, and the order of answers matters, you'd
    do this::

        class Answer(models.Model):
            question = models.ForeignKey(Question)
            # ...

            class Meta:
                order_with_respect_to = 'question'

    When ``order_with_respect_to`` is set, two additional methods are provided to
    retrieve and to set the order of the related objects: ``get_RELATED_order()``
    and ``set_RELATED_order()``, where ``RELATED`` is the lowercased model name. For
    example, assuming that a ``Question`` object has multiple related ``Answer``
    objects, the list returned contains the primary keys of the related ``Answer``
    objects::

        >>> question = Question.objects.get(id=1)
        >>> question.get_answer_order()
        [1, 2, 3]

    The order of a ``Question`` object's related ``Answer`` objects can be set by
    passing in a list of ``Answer`` primary keys::

        >>> question.set_answer_order([3, 1, 2])

    The related objects also get two methods, ``get_next_in_order()`` and
    ``get_previous_in_order()``, which can be used to access those objects in their
    proper order. Assuming the ``Answer`` objects are ordered by ``id``::

        >>> answer = Answer.objects.get(id=2)
        >>> answer.get_next_in_order()
        <Answer: 3>
        >>> answer.get_previous_in_order()
        <Answer: 1>

.. admonition:: Changing order_with_respect_to

        ``order_with_respect_to`` adds an additional field/database column
        named ``_order``, so be sure to handle that as you would any other
        change to your models if you add or change ``order_with_respect_to``
        after your initial :djadmin:`syncdb`.

``ordering``
------------

.. attribute:: Options.ordering

    The default ordering for the object, for use when obtaining lists of objects::

        ordering = ['-order_date']

    This is a tuple or list of strings. Each string is a field name with an optional
    "-" prefix, which indicates descending order. Fields without a leading "-" will
    be ordered ascending. Use the string "?" to order randomly.

    For example, to order by a ``pub_date`` field ascending, use this::

        ordering = ['pub_date']

    To order by ``pub_date`` descending, use this::

        ordering = ['-pub_date']

    To order by ``pub_date`` descending, then by ``author`` ascending, use this::

        ordering = ['-pub_date', 'author']

    .. versionchanged:: 1.4
       The Django admin honors all elements in the list/tuple; before 1.4, only
       the first one was respected.

``permissions``
---------------

.. attribute:: Options.permissions

    Extra permissions to enter into the permissions table when creating this object.
    Add, delete and change permissions are automatically created for each object
    that has ``admin`` set. This example specifies an extra permission,
    ``can_deliver_pizzas``::

        permissions = (("can_deliver_pizzas", "Can deliver pizzas"),)

    This is a list or tuple of 2-tuples in the format ``(permission_code,
    human_readable_permission_name)``.

``proxy``
---------

.. attribute:: Options.proxy

    If ``proxy = True``, a model which subclasses another model will be treated as
    a :ref:`proxy model <proxy-models>`.

``unique_together``
-------------------

.. attribute:: Options.unique_together

    Sets of field names that, taken together, must be unique::

        unique_together = (("driver", "restaurant"),)

    This is a list of lists of fields that must be unique when considered together.
    It's used in the Django admin and is enforced at the database level (i.e., the
    appropriate ``UNIQUE`` statements are included in the ``CREATE TABLE``
    statement).

    For convenience, unique_together can be a single list when dealing with a single
    set of fields::

        unique_together = ("driver", "restaurant")

    A :class:`~django.db.models.ManyToManyField` cannot be included in
    unique_together. (It's not clear what that would even mean!) If you
    need to validate uniqueness related to a
    :class:`~django.db.models.ManyToManyField`, try using a signal or
    an explicit :attr:`through <ManyToManyField.through>` model.

``verbose_name``
----------------

.. attribute:: Options.verbose_name

    A human-readable name for the object, singular::

        verbose_name = "pizza"

    If this isn't given, Django will use a munged version of the class name:
    ``CamelCase`` becomes ``camel case``.

``verbose_name_plural``
-----------------------

.. attribute:: Options.verbose_name_plural

    The plural name for the object::

        verbose_name_plural = "stories"

    If this isn't given, Django will use :attr:`~Options.verbose_name` + ``"s"``.
